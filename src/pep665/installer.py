import hashlib
import logging
import os
import sys
import sysconfig
from platform import python_version
from tempfile import TemporaryDirectory

import tomlkit
from packaging.markers import Marker
from packaging.requirements import Requirement
from packaging.specifiers import SpecifierSet
from packaging.utils import canonicalize_name

from installer import install
from installer.destinations import SchemeDictionaryDestination
from installer.sources import WheelFile

from .tags import validate_wheel_tag

logger = logging.getLogger(__name__)
PYTHON_VERSION = python_version()


class HashMismatchError(Exception):
    pass


def validate_metadata(metadata):
    if metadata.get("marker"):
        if not Marker(metadata["marker"]).evaluate():
            return False
    if metadata.get("tag"):
        if not validate_wheel_tag(metadata["tag"]):
            return False
    if metadata.get("requires-python"):
        if PYTHON_VERSION not in SpecifierSet(metadata["requires-python"]):
            return False
    return True


def validate_package(package):
    wheel_tag = package["filename"][:-4].split("-", 2)[-1]
    if not validate_wheel_tag(wheel_tag):
        logger.debug(
            "Skipping package %s due to incompatible tag %s",
            package["filename"],
            wheel_tag,
        )
        return False
    if package.get("requires-python"):
        if PYTHON_VERSION not in SpecifierSet(package["requires-python"]):
            logger.debug(
                "Skipping package %s due to incompatible python version",
                package["filename"],
            )
            return False
    return True


def download_package(package, downloaddir):
    from urllib.request import urlopen

    logger.info("Fetching package %s...", package["url"])
    url = package["url"]
    filename = package["filename"]
    hash_algo, hash_value = next(iter(package["hashes"].items()))
    hasher = hashlib.new(hash_algo)
    with urlopen(url) as response, open(os.path.join(downloaddir, filename), "wb") as f:
        for chunk in iter(lambda: response.read(10 * 1024), b""):
            hasher.update(chunk)
            f.write(chunk)
    if hasher.hexdigest() != hash_value:
        raise HashMismatchError(
            f"Has mismatch for {url}.\n  Expected: {hash_value}\n  "
            f"Got: {hasher.hexdigest()}"
        )
    return os.path.join(downloaddir, filename)


def _get_script_kind():
    if os.name != "nt":
        return "posix"
    plat = sysconfig.get_platform()
    if plat.endswith("arm32"):
        return plat[:-2]
    if plat == "win32":
        return "ia32"
    return plat


def install_package(wheel, scheme):
    logger.info("Installing package %s...", wheel.split("-", 1)[0])
    destination = SchemeDictionaryDestination(
        scheme,
        interpreter=sys.executable,
        script_kind=_get_script_kind(),
    )

    with WheelFile.open(wheel) as source:
        try:
            install(
                source=source,
                destination=destination,
                # Additional metadata that is generated by the installation tool.
                additional_metadata={
                    "INSTALLER": b"pep665-installer",
                },
            )
        except FileExistsError as e:
            logger.warn(str(e))


def setup_logger():
    logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler()
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)


def install_from_lockfile(namespace):
    if namespace.verbose:
        setup_logger()
    with open(namespace.infile) as f:
        lockfile_data = tomlkit.parse(f.read())
    if not validate_metadata(lockfile_data["metadata"]):
        raise ValueError(
            "The environment does't match lockfile metadata: "
            f"{lockfile_data['metadata']}"
        )
    to_install = lockfile_data["metadata"]["requires"]
    collected = {}
    with TemporaryDirectory(prefix="pep665-installer-") as downloaddir:
        # Perform a BFS to find all the packages that need to be installed
        while to_install:
            req = Requirement(to_install.pop(0))
            name = canonicalize_name(req.name)
            if req.marker and not req.marker.evaluate():
                logger.debug(
                    "Skipping %s because environment markers doesn't match", req
                )
                continue
            if name in collected:
                continue
            versions = lockfile_data["package"][name]
            found = False
            for version, packages in versions.items():
                if version not in req.specifier:
                    continue
                for package in packages:
                    if validate_package(package):
                        collected[name] = (
                            version,
                            download_package(package, downloaddir),
                        )
                        to_install.extend(package["requires"])
                        found = True
                        break
                if found:
                    break
            else:
                raise ValueError(
                    f"Can't find a package entry for {name} that satisfies "
                    "the environment."
                )

        for name, package in collected.items():
            install_package(package[1], sysconfig.get_paths())
    print(
        "Installed packages:",
        ", ".join(
            sorted(f"{name}=={package[0]}" for name, package in collected.items())
        ),
    )
